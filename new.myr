use std

use "readparams"
use "types"

impl disposable byte[:] =
	__dispose__ = {b
		std.slfree(b)
	}
;;

pkg fcgi =
	const read_header	: (fd : std.fd -> std.result((rtype, byte[:]), error))
	const send_response	: (req : request#, data : byte[:] -> std.result(bool, error))
	const announce		: (ds : byte[:] -> std.result(server#, error))
	const get_request	: (srv : server# -> std.result(request#, error))
	const req_free		: (req : request# -> void)
;;

const read_header = {fd
	var buf : byte[fcgi.HEADER_LEN]
	var content, what, version, id, conlen, padlen
	var junk

	match std.read(fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;

		version		= buf[0]

		if version != fcgi.version
			goto version
		;;

		what		= (buf[1] : rtype)
		id		= std.getbe16(buf[2:4])
		conlen		= std.getbe16(buf[4:6])
		padlen		= std.getbe8(buf[6:])
		/* buf[7] is reserved space */
	| `std.Err e: goto short
	;;

	content = std.slalloc(conlen)

	match std.read(fd, content)
	| `std.Ok sz:
		if sz < content.len
			std.slfree(content)
			goto short
		;;
	| `std.Err e:
		std.slfree(content)
		goto short
	;;

	if padlen > 0
		junk = std.slalloc(padlen)
		std.read(fd, junk)
		std.slfree(junk)
	;;

	-> `std.Ok (what, content)

:version
	-> `std.Err `Eversion version

:short
	-> `std.Err `Eshort
}

const prepare_header = {buf, what, id, conlen
	buf[0] = fcgi.version
	std.putbe8(buf[1:], what)
	std.putbe16(buf[2:], id)
	std.putbe16(buf[4:], conlen)
	buf[6] = 0	/* padding length */
	buf[7] = 0	/* reserved space */
}

const send_response = {req, data
	var buf : byte[fcgi.HEADER_LEN]

	prepare_header(buf[:], fcgi.Stdout, 1, data.len)

	match std.write(req.fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	match std.write(req.fd, data)
	| `std.Ok sz:
		if sz < data.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	prepare_header(buf[:], fcgi.EndRequest, 1, fcgi.HEADER_LEN)

	match std.write(req.fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	/* end request data */
	std.putbe32(buf[:4], 0)
	buf[4] = 0
	buf[5] = 0
	buf[6] = 0
	buf[7] = 0

	match std.write(req.fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	-> `std.Ok true

:short
	-> `std.Err `Eshort
}

const read_request = {req
	var err

	while true
		var what, content

		match read_header(req.fd)
		| `std.Ok (w, c):
			what = w
			content = c
		| `std.Err e:
			err = e
			goto err
		;;

		auto content

		match what
		| BeginRequest:
		| Params:
			//parse_params(req, content)
			std.sljoin(&req.paramb, content)
		| Stdin:
			break
		| _:
			err = `Etype what
			goto err
		;;
	;;

	if req.paramb.len > 0
		parse_params(req, req.paramb)
	;;

	-> `std.Ok req

:err
	-> `std.Err err
}

const req_free = {req
	std.close(req.fd)

	var keys = std.htkeys(req.params)
	for k : keys
		match std.htget(req.params, k)
		| `std.Some v:
			std.slfree(v)
			std.slfree(k)
		| `std.None:
		;;
	;;

	std.slfree(keys)

	std.htfree(req.params)
	if req.paramb.len > 0
		std.slfree(req.paramb)
	;;
	std.free(req)
}

const get_request = {srv
	var req
	var err

	req = std.alloc()
	req.params = std.mkht()
	req.paramb = ""

	match std.accept(srv.ann)
	| `std.Ok a: req.fd = a
	| `std.Err e:
		err = `Econn
		goto err
	;;

	match read_request(req)
	| `std.Ok r: req = r
	| `std.Err e:
		err = e
		goto err
	;;

	-> `std.Ok req

:err
	std.htfree(req.params)
	std.free(req)

	-> `std.Err err
}

const announce = {ds
	match std.announce(ds)
	| `std.Ok a:
		-> `std.Ok std.mk([
			.ann=a
		])
	| `std.Err e:
		-> `std.Err `Econn
	;;
}
