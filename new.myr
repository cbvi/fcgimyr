use std

use "types"

pkg fcgi =
	const read_header	: (fd : std.fd -> std.result((rtype, byte[:]), error))
	const send_response	: (fd : std.fd, res : byte[:] -> std.result(bool, error))
;;

const read_header = {fd
	var buf : byte[fcgi.HEADER_LEN]
	var content, what, version, id, conlen, padlen
	var junk

	match std.read(fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;

		version		= buf[0]

		if version != fcgi.version
			goto version
		;;

		what		= (buf[1] : rtype)
		id		= std.getbe16(buf[2:4])
		conlen		= std.getbe16(buf[4:6])
		padlen		= std.getbe8(buf[6:])
		/* buf[7] is reserved space */
	| `std.Err e: goto short
	;;

	content = std.slalloc(conlen)

	match std.read(fd, content)
	| `std.Ok sz:
		if sz < content.len
			std.slfree(content)
			goto short
		;;
	| `std.Err e: goto short
	;;

	if padlen > 0
		junk = std.slalloc(padlen)
		std.read(fd, junk)
		std.slfree(junk)
	;;

	-> `std.Ok (what, content)

:version
	-> `std.Err `Eversion version

:short
	-> `std.Err `Eshort
}

const prepare_header = {buf, what, id, conlen
	buf[0] = fcgi.version
	std.putbe8(buf[1:], what)
	std.putbe16(buf[2:], id)
	std.putbe16(buf[4:], conlen)
	buf[6] = 0	/* padding length */
	buf[7] = 0	/* reserved space */
}

const send_response = {fd, data
	var buf : byte[fcgi.HEADER_LEN]

	prepare_header(buf[:], fcgi.Stdout, 1, data.len)

	match std.write(fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	match std.write(fd, data)
	| `std.Ok sz:
		if sz < data.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	prepare_header(buf[:], fcgi.EndRequest, 1, fcgi.HEADER_LEN)

	match std.write(fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	/* end request data */
	std.putbe32(buf[:4], 0)
	buf[4] = 0
	buf[5] = 0
	buf[6] = 0
	buf[7] = 0

	match std.write(fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	-> `std.Ok true

:short
	-> `std.Err `Eshort
}
