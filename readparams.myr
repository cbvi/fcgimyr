use std

const getval = {buf, len
	if buf.len >= len
		-> `std.Some (buf[:len], buf[len:])
	else
		-> `std.None
	;;
}

const getlen = {buf
	var i
	var lens : uint32[2]

	for i = 0; i < 2; i++
		if buf[0] >> 7 == 0
			if buf.len <= 1
				goto err
			;;
			lens[i] = (buf[0] : uint32)
			buf = buf[1:]
		else
			if buf.len <= 4
				goto err
			;;
			lens[i] = ((((buf[0] : uint32) & 0x7f) << 24) + \
				((buf[1] : uint32) << 16) + \
				((buf[2] : uint32) << 8) + \
				((buf[3] : uint32)))
			buf = buf[4:]
		;;
	;;

	-> `std.Some ((lens[0], lens[1]), buf)

:err
	-> `std.None
}

const parse_params = {txt
	var keylen, vallen, buf
	var key, val
	var ht

	ht = std.mkht()

	buf = txt

	while true
		match getlen(buf)
		| `std.Some (lens, b):
			(keylen, vallen) = lens
			buf = b
		| `std.None: break
		;;

		match getval(buf, keylen)
		| `std.Some (k, b):
			key = k
			buf = b
		| `std.None: break
		;;

		match getval(buf, vallen)
		| `std.Some (v, b):
			val = v
			buf = b
		| `std.None: break
		;;

		std.put("{} {}\n", key, val)

		std.htput(ht, key, val)
	;;

	std.put("{}\n", std.get(std.htget(ht, "HTTP_COOKIE")))

	std.htfree(ht)
}

const main = {
	var txt

	txt = std.try(std.slurp("params.txt"))

	parse_params(txt)
}
