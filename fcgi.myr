use std
use thread

use "params"
use "types"

pkg fcgi =
	const announce		: (ds : byte[:] -> std.result(server#, error))
	const respond		: (req : request#, data : byte[:] -> std.result(void, error))
	const serve		: (srv : server#, fn : (req : request# -> void) -> void)
	const shutdown		: (srv : server# -> void)
;;

const readheader = {fd, content
	var buf : byte[fcgi.Headerlen]
	var what, version, id, conlen, padlen

	match std.readall(fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;

		version		= buf[0]

		if version != fcgi.Version
			goto version
		;;

		what		= (buf[1] : rtype)
		id		= std.getbe16(buf[2:4])
		conlen		= std.getbe16(buf[4:6])
		padlen		= std.getbe8(buf[6:])
		/* buf[7] is reserved space */
	| `std.Err e: goto short
	;;

	match std.readall(fd, content[:conlen + padlen])
	| `std.Ok sz:
		if sz < conlen + padlen
			goto short
		;;
	| `std.Err e: goto short
	;;

	-> `std.Ok (id, what, conlen)

:version
	-> `std.Err `Eversion version

:short
	-> `std.Err `Eshort
}

const prepareheader = {buf, what, id, conlen
	buf[0] = fcgi.Version
	std.putbe8(buf[1:], what)
	std.putbe16(buf[2:], id)
	std.putbe16(buf[4:], conlen)
	buf[6] = 0	/* padding length */
	buf[7] = 0	/* reserved space */
}

const endrequestdata = {buf, appstatus, protocolstatus
	std.putbe32(buf[:4], 0)			/* appStatus */
	buf[4] = (protocolstatus : byte)	/* protocolStatus */
	buf[5] = buf[6] = buf[7] = 0		/* reserved */
}

const sendrecord = {req, content, what
	var header : byte[fcgi.Headerlen]

	prepareheader(header[:], what, req.id, content.len)

	match std.writeall(req.fd, header[:])
	| `std.Ok sz:
		if sz < header.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	match std.writeall(req.fd, content)
	| `std.Ok sz:
		if sz < content.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	-> `std.Ok void

:short
	-> `std.Err `Eshort
}

const respond = {req, data
	var buf : byte[fcgi.Headerlen]
	var len
	const max = 65535

	while data.len > 0
		len = data.len > max ? max : data.len

		sendrecord(req, data[:len], fcgi.Stdout)

		data = data[len:]
	;;

	/* empty stdout record */
	sendrecord(req, fcgi.Empty, fcgi.Stdout)

	endrequestdata(buf[:], 0, fcgi.RequestComplete)
	sendrecord(req, buf[:], fcgi.EndRequest)

	-> `std.Ok void

:short
	-> `std.Err `Eshort
}

const readrequest = {req
	var err
	var content : byte[65535+255]
	var buf, params, stdin

	params = std.mksb()
	stdin = std.mksb()

	while true
		var id, what, conlen

		match readheader(req.fd, content[:])
		| `std.Ok res:
			(id, what, conlen) = res
		| `std.Err e:
			err = e
			goto err
		;;

		if req.id != 0 && req.id != id
			err = `Emis
			goto err
		;;

		buf = content[:conlen]

		match what
		| BeginRequest:
			req.id = id
		| Params:
			std.sbputs(params, buf)
		| Stdin:
			if conlen == 0
				break
			;;
			std.sbputs(stdin, buf)
		| GetValues:
			getvalues(req, buf)
		| _:
			err = `Etype what
			goto err
		;;
	;;

	req.paramb = std.sbfin(params)
	req.stdin = std.sbfin(stdin)

	req.params = parseparams(req.paramb)

	-> `std.Ok void

:err
	std.sbfree(params)
	std.sbfree(stdin)
	-> `std.Err err
}

const getvalues = {req, buf
	var values, sb
	var res : byte[64]

	const maxconns	= "\x0E\x01FCGI_MAX_CONNS1"
	const maxreqs	= "\x0D\x01FCGI_MAX_REQS1"
	const mpxsconns	= "\x0F\x01FCGI_MPXS_CONNS0"

	std.assert(res.len >= maxconns.len + maxreqs.len + mpxsconns.len,
		"getvalues buffer too small to hold all values")

	values = parseparams(buf)
	sb = std.mkbufsb(res[:])

	for value : values
		match value
		| ("FCGI_MAX_CONNS", _):	std.sbputs(sb, maxconns)
		| ("FCGI_MAX_REQS", _):		std.sbputs(sb, maxreqs)
		| ("FCGI_MPXS_CONNS", _):	std.sbputs(sb, mpxsconns)
		| _:
		;;
	;;

	sendrecord(req, std.sbfin(sb), fcgi.GetValuesResult)
}

const reqfree = {req
	std.close(req.fd)
	std.slfree(req.params)
	std.slfree(req.paramb)
	std.slfree(req.stdin)
}

const shutdown = {srv
	srv.running = false
	std.aclose(srv.ann)
}

const serve_cb = {fd, fn
	var req : request

	req.id = 0
	req.params = [][:]
	req.paramb = [][:]
	req.fd = fd
	req.stdin = [][:]

	match readrequest(&req)
	| `std.Ok _:
	| `std.Err e: goto end
	;;

	fn(&req)

:end
	reqfree(&req)
}

const serve = {srv, fn
	while srv.running
		match std.accept(srv.ann)
		| `std.Ok fd:
			serve_cb(fd, fn)
		| `std.Err _:
		;;
	;;

	std.free(srv)
}

const announce = {ds
	match std.announce(ds)
	| `std.Ok a:
		-> `std.Ok std.mk([
			.ann = a,
			.running = true
		])
	| `std.Err e:
		-> `std.Err `Econn
	;;
}
