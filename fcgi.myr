use std
use thread
use utilfcgi

use "types"

pkg fcgi =
	const announce		: (ds : byte[:] -> std.result(server#, error))
	const respond		: (req : request#, data : byte[:] -> std.result(void, error))
	const serve		: (srv : server#, fn : (req : request# -> void) -> void)
	const shutdown		: (srv : server# -> void)
;;

const readrecord = {fd, content
	var buf : byte[utilfcgi.Headerlen]
	var version, what, id, conlen, padlen
	var len

	match utilfcgi.readheader(fd)
	| `std.Some s: (version, what, id, conlen, padlen) = s
	| `std.None: goto short
	;;

	if version != utilfcgi.Version
		goto version
	;;

	len = conlen + padlen

	match std.readall(fd, content[:len])
	| `std.Ok sz:
		if sz < len
			goto short
		;;
	| `std.Err e: goto short
	;;

	-> `std.Ok (id, what, conlen)

:version
	-> `std.Err `Eversion version

:short
	-> `std.Err `Eshort
}

const sendrecord = {req, content, what
	var header : byte[utilfcgi.Headerlen]

	utilfcgi.prepareheader(header[:], what, req.id, content.len)

	-> utilfcgi.sendrecord(req.fd, header[:], content)
}

const respond = {req, data
	var buf : byte[utilfcgi.Headerlen]
	var len
	const max = 65535

	while data.len > 0
		len = data.len > max ? max : data.len

		if !sendrecord(req, data[:len], utilfcgi.Stdout)
			goto short
		;;

		data = data[len:]
	;;

	/* empty stdout record */
	if !sendrecord(req, utilfcgi.Empty, utilfcgi.Stdout)
		goto short
	;;

	utilfcgi.endrequestdata(buf[:], 0, utilfcgi.RequestComplete)

	if !sendrecord(req, buf[:], utilfcgi.EndRequest)
		goto short
	;;

	-> `std.Ok void

:short
	-> `std.Err `Eshort
}

const readrequest = {req
	var err
	var content : byte[65535+255]
	var buf, params, stdin

	params = std.mksb()
	stdin = std.mksb()

	while true
		var id, what, conlen

		match readrecord(req.fd, content[:])
		| `std.Ok res:
			(id, what, conlen) = res
		| `std.Err e:
			err = e
			goto err
		;;

		if req.id != 0 && req.id != id
			err = `Emis
			goto err
		;;

		buf = content[:conlen]

		match what
		| utilfcgi.BeginRequest:
			req.id = id
		| utilfcgi.Params:
			std.sbputs(params, buf)
		| utilfcgi.Stdin:
			if conlen == 0
				break
			;;
			std.sbputs(stdin, buf)
		| utilfcgi.GetValues:
			getvalues(req, buf)
		| _:
			err = `Etype what
			goto err
		;;
	;;

	req.paramb = std.sbfin(params)
	req.stdin = std.sbfin(stdin)

	req.params = utilfcgi.parseparams(req.paramb)

	-> `std.Ok void

:err
	std.sbfree(params)
	std.sbfree(stdin)
	-> `std.Err err
}

const getvalues = {req, buf
	var have : (byte[:], byte[:])[3]
	var want, encoded, ret
	var i = 0

	want = utilfcgi.parseparams(buf)

	for (hk, hv) : fcgi.Values
		for (wk, _) : want
			if std.sleq(hk, wk)
				have[i++] = (hk, hv)
			;;
		;;
	;;

	encoded = utilfcgi.encodeparams(have[:i])

	ret = sendrecord(req, encoded, utilfcgi.GetValuesResult)

	std.slfree(encoded)

	-> ret
}

const reqfree = {req
	std.close(req.fd)
	std.slfree(req.params)
	std.slfree(req.paramb)
	std.slfree(req.stdin)
}

const shutdown = {srv
	srv.running = false
	std.aclose(srv.ann)
}

const serve_cb = {fd, fn
	var req : request

	req.id = 0
	req.params = [][:]
	req.paramb = [][:]
	req.fd = fd
	req.stdin = [][:]

	match readrequest(&req)
	| `std.Ok _:
	| `std.Err e: goto end
	;;

	fn(&req)

:end
	reqfree(&req)
}

const serve = {srv, fn
	while srv.running
		match std.accept(srv.ann)
		| `std.Ok fd:
			serve_cb(fd, fn)
		| `std.Err _:
		;;
	;;

	std.free(srv)
}

const announce = {ds
	match std.announce(ds)
	| `std.Ok a:
		-> `std.Ok std.mk([
			.ann = a,
			.running = true
		])
	| `std.Err e:
		-> `std.Err `Econn
	;;
}
