use std

use "params"
use "types"

impl disposable byte[:] =
	__dispose__ = {b
		std.slfree(b)
	}
;;

pkg fcgi =
	const announce		: (ds : byte[:] -> std.result(server#, error))
	const respond		: (req : request#, data : byte[:] -> std.result(bool, error))
	const serve		: (srv : server#, fn : (req : request# -> void) -> void)
	const shutdown		: (srv : server# -> void)
;;

const readheader = {fd
	var buf : byte[fcgi.Headerlen]
	var content, what, version, id, conlen, padlen

	match std.readall(fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;

		version		= buf[0]

		if version != fcgi.Version
			goto version
		;;

		what		= (buf[1] : rtype)
		id		= std.getbe16(buf[2:4])
		conlen		= std.getbe16(buf[4:6])
		padlen		= std.getbe8(buf[6:])
		/* buf[7] is reserved space */
	| `std.Err e: goto short
	;;

	content = std.slalloc(conlen + padlen)

	match std.readall(fd, content)
	| `std.Ok sz:
		if sz < content.len
			std.slfree(content)
			goto short
		;;
	| `std.Err e:
		std.slfree(content)
		goto short
	;;

	-> `std.Ok (id, what, content[:conlen])

:version
	-> `std.Err `Eversion version

:short
	-> `std.Err `Eshort
}

const prepareheader = {buf, what, id, conlen
	buf[0] = fcgi.Version
	std.putbe8(buf[1:], what)
	std.putbe16(buf[2:], id)
	std.putbe16(buf[4:], conlen)
	buf[6] = 0	/* padding length */
	buf[7] = 0	/* reserved space */
}

const endrequestdata = {buf, appstatus, protocolstatus
	std.putbe32(buf[:4], 0)			/* appStatus */
	buf[4] = (protocolstatus : byte)	/* protocolStatus */
	buf[5] = buf[6] = buf[7] = 0		/* reserved */
}

const respond = {req, data
	var buf : byte[fcgi.Headerlen]
	var len
	const max = 65535

	while data.len > 0
		len = data.len > max ? max : data.len

		prepareheader(buf[:], fcgi.Stdout, req.id, len)

		match std.writeall(req.fd, buf[:])
		| `std.Ok sz:
			if sz < buf.len
				goto short
			;;
		| `std.Err e: goto short
		;;

		match std.writeall(req.fd, data[:len])
		| `std.Ok sz:
			if sz < len
				goto short
			;;
		| `std.Err e: goto short
		;;

		data = data[len:]
	;;

	/* empty stdout record */
	prepareheader(buf[:], fcgi.Stdout, req.id, 0)

	match std.writeall(req.fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	prepareheader(buf[:], fcgi.EndRequest, req.id,
			fcgi.Headerlen)

	match std.writeall(req.fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	endrequestdata(buf[:], 0, fcgi.RequestComplete)

	match std.writeall(req.fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	-> `std.Ok true

:short
	-> `std.Err `Eshort
}

const readrequest = {req
	var err

	while true
		var id, what, content

		match readheader(req.fd)
		| `std.Ok res:
			(id, what, content) = res
		| `std.Err e:
			err = e
			goto err
		;;

		auto content

		if req.id != 0 && req.id != id
			err = `Emis
			goto err
		;;

		match what
		| BeginRequest:
			req.id = id
		| Params:
			std.sljoin(&req.paramb, content)
		| Stdin:
			std.sljoin(&req.stdin, content)
			if content.len == 0
				break
			;;
		| _:
			err = `Etype what
			goto err
		;;
	;;

	parseparams(req, req.paramb)

	-> `std.Ok req

:err
	-> `std.Err err
}

const reqfree = {req
	std.close(req.fd)
	std.slfree(req.params)
	std.slfree(req.paramb)
	std.slfree(req.stdin)
	std.free(req)
}

const shutdown = {srv
	srv.running = false
	std.aclose(srv.ann)
}

const serve_cb = {srv, fn
	var req

	req = std.mk([
		.id = 0,
		.params = [][:],
		.paramb = [][:],
		.fd = -1,
		.stdin = [][:]
	])

	match std.accept(srv.ann)
	| `std.Ok a: req.fd = a
	| `std.Err e: goto end
	;;

	match readrequest(req)
	| `std.Ok r: req = r
	| `std.Err e: goto end
	;;

	fn(req)

:end
	reqfree(req)
}

const serve = {srv, fn
	while srv.running
		serve_cb(srv, fn)
	;;

	std.free(srv)
}

const announce = {ds
	match std.announce(ds)
	| `std.Ok a:
		-> `std.Ok std.mk([
			.ann = a,
			.running = true
		])
	| `std.Err e:
		-> `std.Err `Econn
	;;
}
