use std
use thread

use "params"
use "types"

pkg fcgi =
	const announce		: (ds : byte[:] -> std.result(server#, error))
	const respond		: (req : request#, data : byte[:] -> std.result(bool, error))
	const serve		: (srv : server#, fn : (req : request# -> void) -> void)
	const shutdown		: (srv : server# -> void)
;;

const readheader = {fd, content
	var buf : byte[fcgi.Headerlen]
	var what, version, id, conlen, padlen

	match std.readall(fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;

		version		= buf[0]

		if version != fcgi.Version
			goto version
		;;

		what		= (buf[1] : rtype)
		id		= std.getbe16(buf[2:4])
		conlen		= std.getbe16(buf[4:6])
		padlen		= std.getbe8(buf[6:])
		/* buf[7] is reserved space */
	| `std.Err e: goto short
	;;

	match std.readall(fd, content[:conlen + padlen])
	| `std.Ok sz:
		if sz < conlen + padlen
			goto short
		;;
	| `std.Err e: goto short
	;;

	-> `std.Ok (id, what, conlen)

:version
	-> `std.Err `Eversion version

:short
	-> `std.Err `Eshort
}

const prepareheader = {buf, what, id, conlen
	buf[0] = fcgi.Version
	std.putbe8(buf[1:], what)
	std.putbe16(buf[2:], id)
	std.putbe16(buf[4:], conlen)
	buf[6] = 0	/* padding length */
	buf[7] = 0	/* reserved space */
}

const endrequestdata = {buf, appstatus, protocolstatus
	std.putbe32(buf[:4], 0)			/* appStatus */
	buf[4] = (protocolstatus : byte)	/* protocolStatus */
	buf[5] = buf[6] = buf[7] = 0		/* reserved */
}

const respond = {req, data
	var buf : byte[fcgi.Headerlen]
	var len
	const max = 65535

	while data.len > 0
		len = data.len > max ? max : data.len

		prepareheader(buf[:], fcgi.Stdout, req.id, len)

		match std.writeall(req.fd, buf[:])
		| `std.Ok sz:
			if sz < buf.len
				goto short
			;;
		| `std.Err e: goto short
		;;

		match std.writeall(req.fd, data[:len])
		| `std.Ok sz:
			if sz < len
				goto short
			;;
		| `std.Err e: goto short
		;;

		data = data[len:]
	;;

	/* empty stdout record */
	prepareheader(buf[:], fcgi.Stdout, req.id, 0)

	match std.writeall(req.fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	prepareheader(buf[:], fcgi.EndRequest, req.id,
			fcgi.Headerlen)

	match std.writeall(req.fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	endrequestdata(buf[:], 0, fcgi.RequestComplete)

	match std.writeall(req.fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	-> `std.Ok true

:short
	-> `std.Err `Eshort
}

const readrequest = {req
	var err
	var content : byte[65535+255]
	var params, stdin

	params = std.mksb()
	stdin = std.mksb()

	while true
		var id, what, conlen

		match readheader(req.fd, content[:])
		| `std.Ok res:
			(id, what, conlen) = res
		| `std.Err e:
			err = e
			goto err
		;;

		if req.id != 0 && req.id != id
			err = `Emis
			goto err
		;;

		match what
		| BeginRequest:
			req.id = id
		| Params:
			std.sbputs(params, content[:conlen])
		| Stdin:
			if conlen == 0
				break
			;;
			std.sbputs(stdin, content[:conlen])
		| _:
			err = `Etype what
			goto err
		;;
	;;

	req.paramb = std.sbfin(params)
	req.stdin = std.sbfin(stdin)

	req.params = parseparams(req.paramb)

	-> `std.Ok void

:err
	std.sbfree(params)
	std.sbfree(stdin)
	-> `std.Err err
}

const reqfree = {req
	std.close(req.fd)
	std.slfree(req.params)
	std.slfree(req.paramb)
	std.slfree(req.stdin)
}

const shutdown = {srv
	srv.running = false
	std.aclose(srv.ann)
}

const serve_cb = {fd, fn
	var req : request

	req.id = 0
	req.params = [][:]
	req.paramb = [][:]
	req.fd = fd
	req.stdin = [][:]

	match readrequest(&req)
	| `std.Ok _:
	| `std.Err e: goto end
	;;

	fn(&req)

:end
	reqfree(&req)
}

const serve = {srv, fn
	while srv.running
		match std.accept(srv.ann)
		| `std.Ok fd:
			serve_cb(fd, fn)
		| `std.Err _:
		;;
	;;

	std.free(srv)
}

const announce = {ds
	match std.announce(ds)
	| `std.Ok a:
		-> `std.Ok std.mk([
			.ann = a,
			.running = true
		])
	| `std.Err e:
		-> `std.Err `Econn
	;;
}
