use std

use "params"
use "types"

impl disposable byte[:] =
	__dispose__ = {b
		std.slfree(b)
	}
;;

pkg fcgi =
	const announce		: (ds : byte[:] -> std.result(server#, error))
	const respond		: (req : request#, data : byte[:] -> std.result(bool, error))
	const serve		: (srv : server#, fn : (req : request# -> void) -> void)
;;

const read_header = {fd
	var buf : byte[fcgi.HEADER_LEN]
	var content, what, version, id, conlen, padlen
	var junk

	match std.read(fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;

		version		= buf[0]

		if version != fcgi.version
			goto version
		;;

		what		= (buf[1] : rtype)
		id		= std.getbe16(buf[2:4])
		conlen		= std.getbe16(buf[4:6])
		padlen		= std.getbe8(buf[6:])
		/* buf[7] is reserved space */
	| `std.Err e: goto short
	;;

	content = std.slalloc(conlen)

	match std.read(fd, content)
	| `std.Ok sz:
		if sz < content.len
			std.slfree(content)
			goto short
		;;
	| `std.Err e:
		std.slfree(content)
		goto short
	;;

	if padlen > 0
		junk = std.slalloc(padlen)
		std.read(fd, junk)
		std.slfree(junk)
	;;

	-> `std.Ok (what, content)

:version
	-> `std.Err `Eversion version

:short
	-> `std.Err `Eshort
}

const prepare_header = {buf, what, id, conlen
	buf[0] = fcgi.version
	std.putbe8(buf[1:], what)
	std.putbe16(buf[2:], id)
	std.putbe16(buf[4:], conlen)
	buf[6] = 0	/* padding length */
	buf[7] = 0	/* reserved space */
}

const respond = {req, data
	var buf : byte[fcgi.HEADER_LEN]

	prepare_header(buf[:], fcgi.Stdout, 1, data.len)

	match std.write(req.fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	match std.write(req.fd, data)
	| `std.Ok sz:
		if sz < data.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	prepare_header(buf[:], fcgi.EndRequest, 1, fcgi.HEADER_LEN)

	match std.write(req.fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	/* end request data */
	std.putbe32(buf[:4], 0)
	buf[4] = 0
	buf[5] = 0
	buf[6] = 0
	buf[7] = 0

	match std.write(req.fd, buf[:])
	| `std.Ok sz:
		if sz < buf.len
			goto short
		;;
	| `std.Err e: goto short
	;;

	-> `std.Ok true

:short
	-> `std.Err `Eshort
}

const read_request = {req
	var err

	while true
		var what, content

		match read_header(req.fd)
		| `std.Ok (w, c):
			what = w
			content = c
		| `std.Err e:
			err = e
			goto err
		;;

		auto content

		match what
		| BeginRequest:
		| Params:
			std.sljoin(&req.paramb, content)
		| Stdin:
			std.sljoin(&req.stdin, content)
			if content.len == 0
				break
			;;
		| _:
			err = `Etype what
			goto err
		;;
	;;

	parse_params(req, req.paramb)

	-> `std.Ok req

:err
	-> `std.Err err
}

const req_free = {req
	std.close(req.fd)
	std.slfree(req.params)
	std.slfree(req.paramb)
	std.slfree(req.stdin)
	std.free(req)
}

const serve = {srv, fn
	var req

	while true
		req = std.mk([
			.params = [][:],
			.paramb = [][:],
			.fd = -1,
			.stdin = [][:]
		])

		match std.accept(srv.ann)
		| `std.Ok a: req.fd = a
		| `std.Err e:
			req_free(req)
			continue
		;;

		match read_request(req)
		| `std.Ok r: req = r
		| `std.Err e:
			req_free(req)
			continue
		;;

		fn(req)

		req_free(req)
	;;
}

const announce = {ds
	match std.announce(ds)
	| `std.Ok a:
		-> `std.Ok std.mk([
			.ann=a
		])
	| `std.Err e:
		-> `std.Err `Econn
	;;
}
