use std
use fcgi
use thread
use testr

const BeginRequest = 1
const EndRequest = 3
const Params = 4
const Stdin = 5
const Stdout = 6

const restext = "Content-Type: text/html\r\n\r\ntest"

const cb = {req
	std.try(fcgi.respond(req, restext))
}

const main = {
	var srv

	srv = std.try(fcgi.announce("unix!/tmp/fcgitest.sock"))

	thread.spawn({
		fcgi.serve(srv, cb)
	})

	tests()

	fcgi.shutdown(srv)
}

const header = {buf, rtype, conlen, padlen
	buf[0] = 1
	buf[1] = rtype
	std.putbe16(buf[2:4], 1)
	std.putbe16(buf[4:6], conlen)
	buf[6] = padlen
	buf[7] = 0
}

const tests = {
	var sock
	var buf : byte[8]
	var rec

	sock = std.try(std.dial("unix!/tmp/fcgitest.sock"))

	header(buf[:], BeginRequest, 0, 0)
	std.try(std.write(sock, buf[:]))

	header(buf[:], Params, 0, 0)
	std.try(std.write(sock, buf[:]))

	header(buf[:], Stdin, 4, 0)
	std.try(std.write(sock, buf[:]))
	std.try(std.write(sock, "test"))
	header(buf[:], Stdin, 0, 0)
	std.try(std.write(sock, buf[:]))

	std.read(sock, buf[:])

	rec = std.slalloc(std.getbe16(buf[4:6]))

	std.read(sock, rec)

	std.put("==> {}\n", rec)

	testr.run([
		[.name="test0", .fn={ctx
			match rec
			| restext: std.put("ok\n")
			| val: testr.fail(ctx, "wrong value {}", val)
			;;
		}],
		[.name="test1", .fn={ctx
		}],
	][:])

	std.close(sock)
}
