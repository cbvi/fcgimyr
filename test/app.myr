use std
use fcgi
use thread
use testr

const BeginRequest = 1
const EndRequest = 3
const Params = 4
const Stdin = 5
const Stdout = 6

const restext = "Content-Type: text/html\r\n\r\ntest"

const sockpath = "unix!/tmp/fcgitest.sock"

const cb = {req
	var buf

	buf = std.fmt("{}", restext)

	for param : req.params
		match param
		| ("SERVER_SOFTWARE", v):
			std.sljoin(&buf, v)
		| _:
		;;
	;;

	std.sljoin(&buf, req.stdin)

	std.try(fcgi.respond(req, buf))

	std.slfree(buf)
}

const main = {
	var srv

	srv = std.try(fcgi.announce(sockpath))

	thread.spawn({
		fcgi.serve(srv, cb)
	})

	tests()

	fcgi.shutdown(srv)

	std.exit(0)
}

const header = {buf, rtype, conlen, padlen
	buf[0] = 1
	buf[1] = rtype
	std.putbe16(buf[2:4], 1)
	std.putbe16(buf[4:6], conlen)
	buf[6] = padlen
	buf[7] = 0
}

const basic_test = {ctx
	var sock = std.try(std.dial(sockpath))

	var hdr : byte[8]
	var buf
	var version, what, id, conlen, padlen

	header(hdr[:], BeginRequest, 0, 0)
	std.try(std.write(sock, hdr[:]))

	header(hdr[:], Params, 0, 0)
	std.try(std.write(sock, hdr[:]))

	header(hdr[:], Stdin, 0, 0)
	std.try(std.write(sock, hdr[:]))

	std.try(std.read(sock, hdr[:]))

	version = hdr[0]
	what = hdr[1]
	id = std.getbe16(hdr[2:4])
	conlen = std.getbe16(hdr[4:6])
	padlen = hdr[6]

	testr.check(ctx, version == 1, "wrong version {}", version)
	testr.check(ctx, what == Stdout, "wrong type {}", what)
	testr.check(ctx, id == 1, "wrong id {}", id)
	testr.check(ctx, conlen == restext.len, "wrong conlen {}", conlen)
	testr.check(ctx, padlen == 0, "wrong padlen {}", padlen)

	buf = std.slalloc((conlen + padlen : std.size))

	std.try(std.read(sock, buf))

	match buf
	| restext: testr.ok(ctx)
	| v: testr.fail(ctx, "wrong content \"{}\"", v)
	;;

	std.try(std.read(sock, hdr[:]))
	testr.check(ctx, hdr[1] == Stdout, "wrong type for final stdout {}", hdr[1])
	testr.check(ctx, std.getbe16(hdr[4:6]) == 0, "final stdout has content")

	std.try(std.read(sock, hdr[:]))
	testr.check(ctx, hdr[1] == EndRequest, "wrong type for end {}", hdr[1])

	std.try(std.read(sock, hdr[:]))
	testr.check(ctx, hdr[4] == 0, "wrong protocol status {}", hdr[4])

	std.slfree(buf)
	std.close(sock)
}

const params_test = {ctx
	var sock = std.try(std.dial(sockpath))
	var hdr : byte[8]
	var conlen, padlen, buf
	var params
	var hc = "\0\0\0\0\0HTTP_COOKIEmtest=1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128; Auth-Type=http; Auth-Token=pfGXCtG1aZnpPIEl25HtTyzBvi77W1M6v07sd1blwIYTAHct"
	hc[0] = 11
	hc[1] = 128
	hc[2] = 0
	hc[3] = 1
	hc[4] = 230

	var ss = "\0\0SERVER_SOFTWAREOpenBSD httpd"
	ss[0] = 15
	ss[1] = 13

	params = std.fmt("{}{}", hc, ss)

	header(hdr[:], BeginRequest, 0, 0)
	std.try(std.write(sock, hdr[:]))

	header(hdr[:], Params, params.len, 0)
	std.try(std.write(sock, hdr[:]))
	std.try(std.write(sock, params))

	header(hdr[:], Stdin, 0, 0)
	std.try(std.write(sock, hdr[:]))

	std.try(std.read(sock, hdr[:]))

	conlen = std.getbe16(hdr[4:6])
	padlen = std.getbe8(hdr[6:])

	buf = std.slalloc(conlen + padlen)

	std.try(std.read(sock, buf))

	match buf
	| "Content-Type: text/html\r\n\r\ntestOpenBSD httpd": testr.ok(ctx)
	| v: testr.fail(ctx, "wrong content \"{}\"", v)
	;;

	std.try(std.read(sock, hdr[:]))
	std.try(std.read(sock, hdr[:]))
	std.try(std.read(sock, hdr[:]))

	std.slfree(params)
	std.slfree(buf)
	std.close(sock)
}

const stdin_test = {ctx
	var sock = std.try(std.dial(sockpath))
	var conlen, padlen, buf
	var hdr : byte[8]
	var stdin
	var sbuf, rbuf
	var expected

	/* this is an absurdly large size to test content sent in chunks */ 
	stdin = std.slalloc(209123)

	std.randbytes(stdin[:])

	header(hdr[:], BeginRequest, 0, 0)
	std.try(std.writeall(sock, hdr[:]))

	header(hdr[:], Params, 0, 0)
	std.try(std.writeall(sock, hdr[:]))

	sbuf = stdin

	while sbuf.len > 0
		const max = 65535
		var len = sbuf.len > max ? max : sbuf.len

		header(hdr[:], Stdin, len, 0)
		std.try(std.writeall(sock, hdr[:]))
		std.try(std.writeall(sock, sbuf[:len]))

		sbuf = sbuf[len:]
	;;

	header(hdr[:], Stdin, 0, 0)
	std.try(std.writeall(sock, hdr[:]))

	rbuf = [][:]

	while true
		std.try(std.readall(sock, hdr[:]))

		conlen = std.getbe16(hdr[4:6])
		padlen = std.getbe8(hdr[6:])

		buf = std.slalloc(conlen + padlen)
		std.try(std.readall(sock, buf))
		std.sljoin(&rbuf, buf)
		std.slfree(buf)

		if conlen == 0
			break
		;;
	;;

	expected = std.fmt("{}{}", restext, stdin)

	if std.sleq(expected, rbuf)
		testr.ok(ctx)
	else
		testr.fail(ctx, "data returned didn't match stdin sent")
	;;

	std.try(std.readall(sock, hdr[:]))
	std.try(std.readall(sock, hdr[:]))
	std.try(std.readall(sock, hdr[:]))

	std.slfree(stdin)
	std.slfree(rbuf)
	std.slfree(expected)
	std.close(sock)
}

const tests = {
	testr.run([
		[.name="basic", .fn={ctx
			basic_test(ctx)
		}],
		[.name="params", .fn={ctx
			params_test(ctx)
		}],
		[.name="stdin", .fn={ctx
			stdin_test(ctx)
		}],
	][:])
}
